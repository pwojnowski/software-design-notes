#+TITLE: Emacs Internals - Deep Dive
#+AUTHOR: Technical Reference
#+DATE: [2025-10-31 Fri]
#+DESCRIPTION: Low-level implementation details of Emacs internals

* Introduction

This document explores the internal implementation details of Emacs, going
beyond the architectural overview to understand how specific components work at
a low level.

** Complete Data Flow Overview

[[file:diagrams/complete-data-flow.png]]

* Buffer Internals

** Buffer Structure

Buffers are the fundamental data structure in Emacs, implemented in C.

[[file:diagrams/buffer-internal-structure.png]]

*** Key Components
- *Text*: Gap buffer data structure (see [[*Gap Buffer][Gap Buffer]])
- *Markers*: Positions that move with text
- *Text Properties*: Metadata attached to characters
- *Overlays*: Ranges with properties (independent of text)
- *Local Variables*: Buffer-local variable bindings
- *Syntax Table*: Character syntax classifications
- *Mode*: Major and minor mode information

** Gap Buffer
:PROPERTIES:
:COMPLEXITY: O(1) for insertion at point
:FILE: src/insdel.c
:END:

Emacs uses a *gap buffer* for efficient text editing.

[[file:diagrams/gap-buffer-operations.png]]

#+BEGIN_EXAMPLE
Text: "Hello World"
Cursor position: between "Hello" and " World"

Memory layout:
[H][e][l][l][o][_][_][_][_][_][ ][W][o][r][l][d]
              ↑                ↑
            GAP_START      GAP_END
#+END_EXAMPLE

*** Advantages
- O(1) insertion/deletion at point (cursor position)
- No need to shift text when editing at gap location
- Efficient for typical editing patterns (consecutive edits)

*** Gap Movement
When you move the cursor, the gap moves:
1. Copy text between old gap and new cursor position
2. Update GAP_START and GAP_END pointers

*** Gap Expansion
When gap fills up:
1. Allocate larger buffer
2. Copy text with larger gap
3. Free old buffer

** Markers
:PROPERTIES:
:PURPOSE: Track positions that move with text
:FILE: src/marker.c
:END:

Markers maintain their logical position when text is inserted/deleted.

#+BEGIN_SRC emacs-lisp
;; Create a marker
(setq my-marker (point-marker))

;; Later, even after text changes, the marker
;; still points to the same logical location
(goto-char my-marker)
#+END_SRC

*** Implementation
- Doubly-linked list per buffer
- Updated automatically on text modifications
- Can point into any buffer or nowhere (when buffer is killed)

** Text Properties vs Overlays

*** Text Properties
- Attached directly to characters
- Move with text when copied/killed/yanked
- Stored in interval tree data structure
- Used for: font-lock (syntax highlighting), read-only regions

#+BEGIN_SRC emacs-lisp
;; Add text property
(put-text-property start end 'face 'bold)
#+END_SRC

*** Overlays
- Independent of text content
- Don't move when text is copied
- Stored in separate list per buffer
- Used for: highlighting current line, temporary decorations, company-mode popups

#+BEGIN_SRC emacs-lisp
;; Create overlay
(setq my-overlay (make-overlay start end))
(overlay-put my-overlay 'face 'highlight)
#+END_SRC

*** Performance Comparison
| Operation | Text Properties | Overlays |
|-----------+----------------+----------|
| Lookup    | Fast (O(log n)) | Slow (O(n)) |
| Add/Remove| Moderate | Fast |
| Copy with text | Yes | No |
| Best for | Syntax highlighting | Temporary UI |

* Display Engine (Redisplay)

** The Redisplay Algorithm
:PROPERTIES:
:FILE: src/xdisp.c
:COMPLEXITY: One of the most complex parts of Emacs (~30K lines)
:END:

The redisplay engine updates the screen to reflect buffer contents.

[[file:diagrams/redisplay-engine.png]]

** Key Challenges
1. *Efficiency*: Minimize screen updates
2. *Variable-width fonts*: Character widths vary
3. *Line wrapping*: Visual lines vs logical lines
4. *Bidirectional text*: RTL and LTR text mixed
5. *Images and widgets*: Non-text display elements

** Redisplay Phases

*** Phase 1: Determine What Changed
- Check which buffers modified since last redisplay
- Check which windows show modified buffers
- Determine if window configuration changed

*** Phase 2: Build Glyph Matrices
Transform buffer contents into display glyphs:
- Apply faces (fonts, colors)
- Handle text properties and overlays
- Process display properties (images, custom strings)
- Compute line breaks and wrapping

*** Phase 3: Update Screen
- Compare new glyph matrix with old
- Send minimum changes to terminal/GUI
- Optimize for scrolling regions

** Optimization Techniques

*** Unchanged Text Optimization
If buffer hasn't changed and window hasn't scrolled:
→ Skip redisplay entirely

*** Scrolling Optimization
If only scroll position changed:
→ Use terminal scroll commands instead of redrawing

*** Glyph Matrix Reuse
Keep old glyph matrices and compare:
→ Only update changed portions

* Garbage Collection

** Implementation
:PROPERTIES:
:ALGORITHM: Mark and Sweep
:FILE: src/alloc.c
:END:

Emacs uses a traditional mark-and-sweep garbage collector.

[[file:diagrams/garbage-collection.png]]

** GC Phases

*** Mark Phase
1. Start from GC roots:
   - All Lisp variables
   - Current stack frames
   - All buffers, windows, frames
   - Symbol obarray
2. Recursively mark all reachable objects
3. Set mark bit on each reachable object

*** Sweep Phase
1. Scan all allocated objects
2. Free unmarked objects
3. Clear mark bits on surviving objects
4. Consolidate free lists

** Object Types

Each Lisp object type has its own free list:
- Cons cells
- Strings
- Vectors
- Symbols
- Floats
- etc.

** GC Triggering

GC runs when:
- Allocation fails (out of memory in free list)
- Explicit call to =(garbage-collect)=
- After certain number of allocations (=gc-cons-threshold=)

#+BEGIN_SRC emacs-lisp
;; Default: GC after ~800KB of allocations
gc-cons-threshold  ; => 800000

;; Increase to reduce GC frequency (startup optimization)
(setq gc-cons-threshold (* 50 1000 1000))  ; 50MB
#+END_SRC

** GC Performance Tips
- Increase =gc-cons-threshold= during initialization
- Reduce consing in tight loops
- Reuse objects when possible
- Monitor with =garbage-collect= return value

* Byte-code and Compilation

** Byte-code Format
:PROPERTIES:
:PURPOSE: Platform-independent compiled format
:FILE: src/bytecode.c
:END:

Elisp can be byte-compiled for better performance.

** Byte-code Instructions

Sample instructions:
- =Bvarref= - Variable reference
- =Bvarset= - Variable assignment
- =Bcall= - Function call
- =Bgoto= - Jump
- =Breturn= - Return from function

** Example Compilation

#+BEGIN_SRC emacs-lisp
;; Source code
(defun add-one (x)
  (+ x 1))

;; Disassemble to see byte-code
(disassemble 'add-one)
#+END_SRC

Output:
#+BEGIN_EXAMPLE
byte code:
  args: (x)
0       varref    x
1       constant  1
2       plus
3       return
#+END_EXAMPLE

** Performance Impact

| Code Type | Relative Speed |
|-----------+----------------|
| Interpreted | 1x (baseline) |
| Byte-compiled | 5-10x faster |
| Native compiled | 2-3x faster than byte-code |

* Native Compilation
:PROPERTIES:
:FEATURE: Added in Emacs 28
:TECHNOLOGY: libgccjit
:END:

Modern Emacs can compile Elisp to native machine code.

** How It Works

1. Elisp → Byte-code (traditional compilation)
2. Byte-code → GCC IR (intermediate representation)
3. GCC IR → Native code (libgccjit)
4. Cache .eln files in =native-comp-eln-load-path=

** Benefits
- 2-3x faster than byte-code
- Especially benefits tight loops and recursive functions
- Transparent to code (no changes needed)

** Configuration

#+BEGIN_SRC emacs-lisp
;; Check if native compilation is available
(native-comp-available-p)  ; => t

;; Compile a function
(native-compile 'my-function)

;; Compile a file
(native-compile "~/.emacs.d/init.el")
#+END_SRC

* Symbol Implementation

** Symbols
:PROPERTIES:
:DEFINITION: Named objects with multiple cells
:FILE: src/symbols.c
:END:

Symbols are more than just names - they're complex objects.

[[file:diagrams/symbol-structure.png]]

** Symbol Components

Each symbol has:
- *Name*: String name
- *Value cell*: Variable binding
- *Function cell*: Function binding
- *Property list*: Arbitrary properties
- *Interned flag*: Is it in obarray?

#+BEGIN_SRC emacs-lisp
;; One symbol, multiple roles
(defvar my-symbol 42)           ; Value cell
(defun my-symbol () "hello")    ; Function cell
(put 'my-symbol 'doc "docs")    ; Property list

;; Access different cells
(symbol-value 'my-symbol)       ; => 42
(symbol-function 'my-symbol)    ; => (closure ...)
(symbol-plist 'my-symbol)       ; => (doc "docs")
#+END_SRC

** The Obarray
:PROPERTIES:
:STRUCTURE: Hash table of symbols
:PURPOSE: Symbol interning
:END:

The obarray ensures symbol uniqueness.

#+BEGIN_SRC emacs-lisp
;; Reading 'foo multiple times gives same symbol
(eq 'foo 'foo)  ; => t

;; They're literally the same object in memory
(eq (intern "foo") (intern "foo"))  ; => t
#+END_SRC

* Keymaps and Key Lookup

** Keymap Structure
:PROPERTIES:
:TYPE: Sparse tree structure
:FILE: src/keymap.c
:END:

Keymaps map key sequences to commands.

[[file:diagrams/keymap-lookup-algorithm.png]]

** Keymap Types

*** Full Keymaps
- Array of 128 ASCII characters
- Plus alist for non-ASCII

*** Sparse Keymaps
- Alist only (no array)
- More memory efficient

*** Keymap Inheritance
Keymaps can have parent keymaps:

#+BEGIN_EXAMPLE
python-mode-map
    ↓ (inherits from)
prog-mode-map
    ↓ (inherits from)
global-map
#+END_EXAMPLE

** Key Lookup Algorithm

When you press a key sequence (e.g., =C-x C-f=):

1. Build key sequence list: =(?\C-x ?\C-f)=
2. Search keymaps in order:
   - Overriding keymaps
   - Each active minor mode keymap (in order)
   - Current buffer's major mode keymap
   - Global keymap
3. First match wins
4. Execute associated command

** Prefix Keys

Special keymap entries that expect more keys:
- =C-x= is a prefix key
- =C-x C-f= uses =C-x= map, then looks up =C-f=

* Dynamic vs Lexical Binding

** Historical Context
- Emacs traditionally used dynamic binding
- Lexical binding added in Emacs 24 (2012)
- Now recommended for all new code

** Dynamic Binding (Old Style)
:PROPERTIES:
:SCOPE: Based on call stack
:END:

#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: nil -*-

(defvar x 1)

(defun foo ()
  (+ x 1))

(defun bar ()
  (let ((x 10))
    (foo)))  ; => 11 (uses x from bar's binding)
#+END_SRC

** Lexical Binding (Modern)
:PROPERTIES:
:SCOPE: Based on where defined
:END:

#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-

(defvar x 1)

(defun foo ()
  (+ x 1))

(defun bar ()
  (let ((x 10))
    (foo)))  ; => 2 (uses global x)
#+END_SRC

** Implementation Difference

*** Dynamic Binding
- Variable lookup checks stack frames
- Slower (runtime lookup)
- Can be useful for configuration (rare)

*** Lexical Binding
- Variable lookup determined at compile time
- Faster (direct reference)
- Enables optimizations (closure elimination)
- Allows proper closures

* Process Management

[[file:diagrams/process-management.png]]

** Process Types
:PROPERTIES:
:FILE: src/process.c
:END:

*** Synchronous Processes
Block until completion:

#+BEGIN_SRC emacs-lisp
(call-process "ls" nil t nil "-l")
#+END_SRC

*** Asynchronous Processes
Run in background:

#+BEGIN_SRC emacs-lisp
(start-process "my-ls" "*output*" "ls" "-l")
#+END_SRC

*** Network Processes
TCP/UDP connections:

#+BEGIN_SRC emacs-lisp
(make-network-process
 :name "http-client"
 :host "example.com"
 :service 80)
#+END_SRC

** Process Filters

Handle output asynchronously:

#+BEGIN_SRC emacs-lisp
(defun my-filter (proc string)
  (with-current-buffer (process-buffer proc)
    (insert string)))

(set-process-filter my-process 'my-filter)
#+END_SRC

** Sentinel Functions

Notified when process state changes:

#+BEGIN_SRC emacs-lisp
(defun my-sentinel (proc event)
  (message "Process %s: %s" proc event))

(set-process-sentinel my-process 'my-sentinel)
#+END_SRC

* Undo System

** Undo List Structure
:PROPERTIES:
:BUFFER_LOCAL: t
:VARIABLE: buffer-undo-list
:END:

Each buffer maintains an undo list.

** Undo Entry Types

#+BEGIN_SRC emacs-lisp
;; Text insertion
(BEG . END)  ; "Inserted text from BEG to END"

;; Text deletion
(BEG . "deleted text")  ; "Deleted this text at BEG"

;; Property change
(BEG END PROP VALUE)

;; Marker adjustment
(marker . adjustment)

;; Boundary between commands
nil
#+END_SRC

** Example Undo List

After typing "hello":

#+BEGIN_SRC emacs-lisp
buffer-undo-list
=> (
    (1 . 6)       ; Inserted "hello" (5 chars at position 1)
    nil           ; Command boundary
   )
#+END_SRC

** Undo Limits

#+BEGIN_SRC emacs-lisp
undo-limit              ; Ordinary command undo limit
undo-strong-limit       ; Strong command undo limit
undo-outer-limit        ; Maximum size of undo data
#+END_SRC

* Syntax Tables
:PROPERTIES:
:PURPOSE: Character classification for parsing
:FILE: src/syntax.c
:END:

Syntax tables define character classes for each mode.

** Syntax Classes

| Code | Class              | Example          |
|------+--------------------+------------------|
| -    | Whitespace         | space, tab       |
| w    | Word constituent   | a-z, A-Z         |
| _    | Symbol constituent | -, _             |
| .    | Punctuation        | ., ,             |
| (    | Open parenthesis   | (, [, {          |
| )    | Close parenthesis  | ), ], }          |
| "    | String quote       | "                |
| $    | Paired delimiter   | $                |
| '    | Expression prefix  | '                |
| <    | Comment starter    | /*, <!--         |
| >    | Comment ender      | */, -->          |
| !    | Generic comment    | #                |
| \    |                    | Generic string \ |

** Using Syntax Tables

#+BEGIN_SRC emacs-lisp
;; Get syntax of character
(syntax-class (syntax-after (point)))

;; Modify syntax table
(modify-syntax-entry ?_ "w" python-mode-syntax-table)
;; Now underscore is a word constituent in Python mode
#+END_SRC

* Performance Profiling

** Built-in Profiler
:PROPERTIES:
:PACKAGE: profiler.el
:END:

#+BEGIN_SRC emacs-lisp
;; Start CPU profiler
(profiler-start 'cpu)

;; Do some work...
(my-slow-function)

;; Stop and view results
(profiler-stop)
(profiler-report)
#+END_SRC

** Benchmark Helper

#+BEGIN_SRC emacs-lisp
;; Time a function
(benchmark-run 100
  (my-function))
;; => (0.523 2 0.4)  ; (total-time GCs GC-time)
#+END_SRC

** Memory Profiling

#+BEGIN_SRC emacs-lisp
;; Start memory profiler
(profiler-start 'mem)

;; Your code...

(profiler-stop)
(profiler-report)
#+END_SRC

* Advanced Topics

** Subprocesses and PTY

Emacs can use pipes or PTY for subprocess communication:
- Pipes: Better for non-interactive processes
- PTY: Required for interactive programs (shells, REPLs)

** Module System (Dynamic Modules)

Since Emacs 25, you can write C modules:

#+BEGIN_SRC c
// Simple module in C
int plugin_is_GPL_compatible;

static emacs_value
my_function (emacs_env *env, ptrdiff_t nargs,
             emacs_value args[], void *data)
{
  // Implementation
}
#+END_SRC

** Tree-sitter Integration

Emacs 29+ includes tree-sitter support:
- Incremental parsing
- Better syntax highlighting
- Structural navigation

* Debugging Internals

** Useful Commands

#+BEGIN_SRC emacs-lisp
;; View all buffers (including hidden)
(buffer-list)

;; See all markers in current buffer
(buffer-local-variables)

;; View all overlays
(overlays-in (point-min) (point-max))

;; Memory usage
(memory-use-counts)

;; GC statistics
(garbage-collect)
#+END_SRC

** Debug on Error

#+BEGIN_SRC emacs-lisp
(setq debug-on-error t)
;; Now errors will drop into debugger
#+END_SRC

* References

- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/][GNU Emacs Lisp Reference Manual]]
- =src/= directory in Emacs source tree
- [[info:elisp#Top][Info: Elisp Manual]] (C-h i m Elisp RET)
- =C-h f= and =C-h v= for function/variable documentation

* Source Code Organization

Key source files:
- =src/alloc.c= - Memory allocation and GC
- =src/buffer.c= - Buffer implementation
- =src/xdisp.c= - Display engine (30K+ lines!)
- =src/keyboard.c= - Input handling
- =src/eval.c= - Lisp evaluator
- =src/bytecode.c= - Byte-code interpreter
- =src/syntax.c= - Syntax tables
- =src/process.c= - Process management
- =lisp/simple.el= - Basic editing commands
- =lisp/files.el= - File operations

#+BEGIN_QUOTE
"Emacs is a great operating system, lacking only a decent editor."
— Common joke highlighting Emacs' comprehensive internals
#+END_QUOTE
* Diagrams
** Buffer Internal Structure

[[file:diagrams/buffer-internal-structure.puml][PlantUML Source]] | [[file:diagrams/buffer-internal-structure.png][PNG Image]]
** Gap Buffer Operations

[[file:diagrams/gap-buffer-operations.puml][PlantUML Source]] | [[file:diagrams/gap-buffer-operations.png][PNG Image]]
** Redisplay Engine

[[file:diagrams/redisplay-engine.puml][PlantUML Source]] | [[file:diagrams/redisplay-engine.png][PNG Image]]
** Garbage Collection

[[file:diagrams/garbage-collection.puml][PlantUML Source]] | [[file:diagrams/garbage-collection.png][PNG Image]]
** Symbol Structure

[[file:diagrams/symbol-structure.puml][PlantUML Source]] | [[file:diagrams/symbol-structure.png][PNG Image]]
** Keymap Lookup Algorithm

[[file:diagrams/keymap-lookup-algorithm.puml][PlantUML Source]] | [[file:diagrams/keymap-lookup-algorithm.png][PNG Image]]
** Process Management

[[file:diagrams/process-management.puml][PlantUML Source]] | [[file:diagrams/process-management.png][PNG Image]]
** Complete Data Flow

[[file:diagrams/complete-data-flow.puml][PlantUML Source]] | [[file:diagrams/complete-data-flow.png][PNG Image]]
