#+TITLE: Emacs Internals - Deep Dive
#+AUTHOR: Technical Reference
#+DATE: [2025-10-31 Fri]
#+DESCRIPTION: Low-level implementation details of Emacs internals

* Introduction

This document explores the internal implementation details of Emacs, going
beyond the architectural overview to understand how specific components work at
a low level.

* Buffer Internals

** Buffer Structure

Buffers are the fundamental data structure in Emacs, implemented in C.

*** Key Components
- *Text*: Gap buffer data structure (see [[*Gap Buffer][Gap Buffer]])
- *Markers*: Positions that move with text
- *Text Properties*: Metadata attached to characters
- *Overlays*: Ranges with properties (independent of text)
- *Local Variables*: Buffer-local variable bindings
- *Syntax Table*: Character syntax classifications
- *Mode*: Major and minor mode information

** Gap Buffer
:PROPERTIES:
:COMPLEXITY: O(1) for insertion at point
:FILE: src/insdel.c
:END:

Emacs uses a *gap buffer* for efficient text editing.

#+BEGIN_EXAMPLE
Text: "Hello World"
Cursor position: between "Hello" and " World"

Memory layout:
[H][e][l][l][o][_][_][_][_][_][ ][W][o][r][l][d]
              ↑                ↑
            GAP_START      GAP_END
#+END_EXAMPLE

*** Advantages
- O(1) insertion/deletion at point (cursor position)
- No need to shift text when editing at gap location
- Efficient for typical editing patterns (consecutive edits)

*** Gap Movement
When you move the cursor, the gap moves:
1. Copy text between old gap and new cursor position
2. Update GAP_START and GAP_END pointers

*** Gap Expansion
When gap fills up:
1. Allocate larger buffer
2. Copy text with larger gap
3. Free old buffer

** Markers
:PROPERTIES:
:PURPOSE: Track positions that move with text
:FILE: src/marker.c
:END:

Markers maintain their logical position when text is inserted/deleted.

#+BEGIN_SRC emacs-lisp
;; Create a marker
(setq my-marker (point-marker))

;; Later, even after text changes, the marker
;; still points to the same logical location
(goto-char my-marker)
#+END_SRC

*** Implementation
- Doubly-linked list per buffer
- Updated automatically on text modifications
- Can point into any buffer or nowhere (when buffer is killed)

** Text Properties vs Overlays

*** Text Properties
- Attached directly to characters
- Move with text when copied/killed/yanked
- Stored in interval tree data structure
- Used for: font-lock (syntax highlighting), read-only regions

#+BEGIN_SRC emacs-lisp
;; Add text property
(put-text-property start end 'face 'bold)
#+END_SRC

*** Overlays
- Independent of text content
- Don't move when text is copied
- Stored in separate list per buffer
- Used for: highlighting current line, temporary decorations, company-mode popups

#+BEGIN_SRC emacs-lisp
;; Create overlay
(setq my-overlay (make-overlay start end))
(overlay-put my-overlay 'face 'highlight)
#+END_SRC

*** Performance Comparison
| Operation | Text Properties | Overlays |
|-----------+----------------+----------|
| Lookup    | Fast (O(log n)) | Slow (O(n)) |
| Add/Remove| Moderate | Fast |
| Copy with text | Yes | No |
| Best for | Syntax highlighting | Temporary UI |

* Display Engine (Redisplay)

** The Redisplay Algorithm
:PROPERTIES:
:FILE: src/xdisp.c
:COMPLEXITY: One of the most complex parts of Emacs (~30K lines)
:END:

The redisplay engine updates the screen to reflect buffer contents.

** Key Challenges
1. *Efficiency*: Minimize screen updates
2. *Variable-width fonts*: Character widths vary
3. *Line wrapping*: Visual lines vs logical lines
4. *Bidirectional text*: RTL and LTR text mixed
5. *Images and widgets*: Non-text display elements

** Redisplay Phases

*** Phase 1: Determine What Changed
- Check which buffers modified since last redisplay
- Check which windows show modified buffers
- Determine if window configuration changed

*** Phase 2: Build Glyph Matrices
Transform buffer contents into display glyphs:
- Apply faces (fonts, colors)
- Handle text properties and overlays
- Process display properties (images, custom strings)
- Compute line breaks and wrapping

*** Phase 3: Update Screen
- Compare new glyph matrix with old
- Send minimum changes to terminal/GUI
- Optimize for scrolling regions

** Optimization Techniques

*** Unchanged Text Optimization
If buffer hasn't changed and window hasn't scrolled:
→ Skip redisplay entirely

*** Scrolling Optimization
If only scroll position changed:
→ Use terminal scroll commands instead of redrawing

*** Glyph Matrix Reuse
Keep old glyph matrices and compare:
→ Only update changed portions

* Garbage Collection

** Implementation
:PROPERTIES:
:ALGORITHM: Mark and Sweep
:FILE: src/alloc.c
:END:

Emacs uses a traditional mark-and-sweep garbage collector.

** GC Phases

*** Mark Phase
1. Start from GC roots:
   - All Lisp variables
   - Current stack frames
   - All buffers, windows, frames
   - Symbol obarray
2. Recursively mark all reachable objects
3. Set mark bit on each reachable object

*** Sweep Phase
1. Scan all allocated objects
2. Free unmarked objects
3. Clear mark bits on surviving objects
4. Consolidate free lists

** Object Types

Each Lisp object type has its own free list:
- Cons cells
- Strings
- Vectors
- Symbols
- Floats
- etc.

** GC Triggering

GC runs when:
- Allocation fails (out of memory in free list)
- Explicit call to =(garbage-collect)=
- After certain number of allocations (=gc-cons-threshold=)

#+BEGIN_SRC emacs-lisp
;; Default: GC after ~800KB of allocations
gc-cons-threshold  ; => 800000

;; Increase to reduce GC frequency (startup optimization)
(setq gc-cons-threshold (* 50 1000 1000))  ; 50MB
#+END_SRC

** GC Performance Tips
- Increase =gc-cons-threshold= during initialization
- Reduce consing in tight loops
- Reuse objects when possible
- Monitor with =garbage-collect= return value

* Byte-code and Compilation

** Byte-code Format
:PROPERTIES:
:PURPOSE: Platform-independent compiled format
:FILE: src/bytecode.c
:END:

Elisp can be byte-compiled for better performance.

** Byte-code Instructions

Sample instructions:
- =Bvarref= - Variable reference
- =Bvarset= - Variable assignment
- =Bcall= - Function call
- =Bgoto= - Jump
- =Breturn= - Return from function

** Example Compilation

#+BEGIN_SRC emacs-lisp
;; Source code
(defun add-one (x)
  (+ x 1))

;; Disassemble to see byte-code
(disassemble 'add-one)
#+END_SRC

Output:
#+BEGIN_EXAMPLE
byte code:
  args: (x)
0       varref    x
1       constant  1
2       plus
3       return
#+END_EXAMPLE

** Performance Impact

| Code Type | Relative Speed |
|-----------+----------------|
| Interpreted | 1x (baseline) |
| Byte-compiled | 5-10x faster |
| Native compiled | 2-3x faster than byte-code |

* Native Compilation
:PROPERTIES:
:FEATURE: Added in Emacs 28
:TECHNOLOGY: libgccjit
:END:

Modern Emacs can compile Elisp to native machine code.

** How It Works

1. Elisp → Byte-code (traditional compilation)
2. Byte-code → GCC IR (intermediate representation)
3. GCC IR → Native code (libgccjit)
4. Cache .eln files in =native-comp-eln-load-path=

** Benefits
- 2-3x faster than byte-code
- Especially benefits tight loops and recursive functions
- Transparent to code (no changes needed)

** Configuration

#+BEGIN_SRC emacs-lisp
;; Check if native compilation is available
(native-comp-available-p)  ; => t

;; Compile a function
(native-compile 'my-function)

;; Compile a file
(native-compile "~/.emacs.d/init.el")
#+END_SRC

* Symbol Implementation

** Symbols
:PROPERTIES:
:DEFINITION: Named objects with multiple cells
:FILE: src/symbols.c
:END:

Symbols are more than just names - they're complex objects.

** Symbol Components

Each symbol has:
- *Name*: String name
- *Value cell*: Variable binding
- *Function cell*: Function binding
- *Property list*: Arbitrary properties
- *Interned flag*: Is it in obarray?

#+BEGIN_SRC emacs-lisp
;; One symbol, multiple roles
(defvar my-symbol 42)           ; Value cell
(defun my-symbol () "hello")    ; Function cell
(put 'my-symbol 'doc "docs")    ; Property list

;; Access different cells
(symbol-value 'my-symbol)       ; => 42
(symbol-function 'my-symbol)    ; => (closure ...)
(symbol-plist 'my-symbol)       ; => (doc "docs")
#+END_SRC

** The Obarray
:PROPERTIES:
:STRUCTURE: Hash table of symbols
:PURPOSE: Symbol interning
:END:

The obarray ensures symbol uniqueness.

#+BEGIN_SRC emacs-lisp
;; Reading 'foo multiple times gives same symbol
(eq 'foo 'foo)  ; => t

;; They're literally the same object in memory
(eq (intern "foo") (intern "foo"))  ; => t
#+END_SRC

* Keymaps and Key Lookup

** Keymap Structure
:PROPERTIES:
:TYPE: Sparse tree structure
:FILE: src/keymap.c
:END:

Keymaps map key sequences to commands.

** Keymap Types

*** Full Keymaps
- Array of 128 ASCII characters
- Plus alist for non-ASCII

*** Sparse Keymaps
- Alist only (no array)
- More memory efficient

*** Keymap Inheritance
Keymaps can have parent keymaps:

#+BEGIN_EXAMPLE
python-mode-map
    ↓ (inherits from)
prog-mode-map
    ↓ (inherits from)
global-map
#+END_EXAMPLE

** Key Lookup Algorithm

When you press a key sequence (e.g., =C-x C-f=):

1. Build key sequence list: =(?\C-x ?\C-f)=
2. Search keymaps in order:
   - Overriding keymaps
   - Each active minor mode keymap (in order)
   - Current buffer's major mode keymap
   - Global keymap
3. First match wins
4. Execute associated command

** Prefix Keys

Special keymap entries that expect more keys:
- =C-x= is a prefix key
- =C-x C-f= uses =C-x= map, then looks up =C-f=

* Dynamic vs Lexical Binding

** Historical Context
- Emacs traditionally used dynamic binding
- Lexical binding added in Emacs 24 (2012)
- Now recommended for all new code

** Dynamic Binding (Old Style)
:PROPERTIES:
:SCOPE: Based on call stack
:END:

#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: nil -*-

(defvar x 1)

(defun foo ()
  (+ x 1))

(defun bar ()
  (let ((x 10))
    (foo)))  ; => 11 (uses x from bar's binding)
#+END_SRC

** Lexical Binding (Modern)
:PROPERTIES:
:SCOPE: Based on where defined
:END:

#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-

(defvar x 1)

(defun foo ()
  (+ x 1))

(defun bar ()
  (let ((x 10))
    (foo)))  ; => 2 (uses global x)
#+END_SRC

** Implementation Difference

*** Dynamic Binding
- Variable lookup checks stack frames
- Slower (runtime lookup)
- Can be useful for configuration (rare)

*** Lexical Binding
- Variable lookup determined at compile time
- Faster (direct reference)
- Enables optimizations (closure elimination)
- Allows proper closures

* Process Management

** Process Types
:PROPERTIES:
:FILE: src/process.c
:END:

*** Synchronous Processes
Block until completion:

#+BEGIN_SRC emacs-lisp
(call-process "ls" nil t nil "-l")
#+END_SRC

*** Asynchronous Processes
Run in background:

#+BEGIN_SRC emacs-lisp
(start-process "my-ls" "*output*" "ls" "-l")
#+END_SRC

*** Network Processes
TCP/UDP connections:

#+BEGIN_SRC emacs-lisp
(make-network-process
 :name "http-client"
 :host "example.com"
 :service 80)
#+END_SRC

** Process Filters

Handle output asynchronously:

#+BEGIN_SRC emacs-lisp
(defun my-filter (proc string)
  (with-current-buffer (process-buffer proc)
    (insert string)))

(set-process-filter my-process 'my-filter)
#+END_SRC

** Sentinel Functions

Notified when process state changes:

#+BEGIN_SRC emacs-lisp
(defun my-sentinel (proc event)
  (message "Process %s: %s" proc event))

(set-process-sentinel my-process 'my-sentinel)
#+END_SRC

* Undo System

** Undo List Structure
:PROPERTIES:
:BUFFER_LOCAL: t
:VARIABLE: buffer-undo-list
:END:

Each buffer maintains an undo list.

** Undo Entry Types

#+BEGIN_SRC emacs-lisp
;; Text insertion
(BEG . END)  ; "Inserted text from BEG to END"

;; Text deletion
(BEG . "deleted text")  ; "Deleted this text at BEG"

;; Property change
(BEG END PROP VALUE)

;; Marker adjustment
(marker . adjustment)

;; Boundary between commands
nil
#+END_SRC

** Example Undo List

After typing "hello":

#+BEGIN_SRC emacs-lisp
buffer-undo-list
=> (
    (1 . 6)       ; Inserted "hello" (5 chars at position 1)
    nil           ; Command boundary
   )
#+END_SRC

** Undo Limits

#+BEGIN_SRC emacs-lisp
undo-limit              ; Ordinary command undo limit
undo-strong-limit       ; Strong command undo limit
undo-outer-limit        ; Maximum size of undo data
#+END_SRC

* Syntax Tables
:PROPERTIES:
:PURPOSE: Character classification for parsing
:FILE: src/syntax.c
:END:

Syntax tables define character classes for each mode.

** Syntax Classes

| Code | Class              | Example          |
|------+--------------------+------------------|
| -    | Whitespace         | space, tab       |
| w    | Word constituent   | a-z, A-Z         |
| _    | Symbol constituent | -, _             |
| .    | Punctuation        | ., ,             |
| (    | Open parenthesis   | (, [, {          |
| )    | Close parenthesis  | ), ], }          |
| "    | String quote       | "                |
| $    | Paired delimiter   | $                |
| '    | Expression prefix  | '                |
| <    | Comment starter    | /*, <!--         |
| >    | Comment ender      | */, -->          |
| !    | Generic comment    | #                |
| \    |                    | Generic string \ |

** Using Syntax Tables

#+BEGIN_SRC emacs-lisp
;; Get syntax of character
(syntax-class (syntax-after (point)))

;; Modify syntax table
(modify-syntax-entry ?_ "w" python-mode-syntax-table)
;; Now underscore is a word constituent in Python mode
#+END_SRC

* Performance Profiling

** Built-in Profiler
:PROPERTIES:
:PACKAGE: profiler.el
:END:

#+BEGIN_SRC emacs-lisp
;; Start CPU profiler
(profiler-start 'cpu)

;; Do some work...
(my-slow-function)

;; Stop and view results
(profiler-stop)
(profiler-report)
#+END_SRC

** Benchmark Helper

#+BEGIN_SRC emacs-lisp
;; Time a function
(benchmark-run 100
  (my-function))
;; => (0.523 2 0.4)  ; (total-time GCs GC-time)
#+END_SRC

** Memory Profiling

#+BEGIN_SRC emacs-lisp
;; Start memory profiler
(profiler-start 'mem)

;; Your code...

(profiler-stop)
(profiler-report)
#+END_SRC

* Advanced Topics

** Subprocesses and PTY

Emacs can use pipes or PTY for subprocess communication:
- Pipes: Better for non-interactive processes
- PTY: Required for interactive programs (shells, REPLs)

** Module System (Dynamic Modules)

Since Emacs 25, you can write C modules:

#+BEGIN_SRC c
// Simple module in C
int plugin_is_GPL_compatible;

static emacs_value
my_function (emacs_env *env, ptrdiff_t nargs,
             emacs_value args[], void *data)
{
  // Implementation
}
#+END_SRC

** Tree-sitter Integration

Emacs 29+ includes tree-sitter support:
- Incremental parsing
- Better syntax highlighting
- Structural navigation

* Debugging Internals

** Useful Commands

#+BEGIN_SRC emacs-lisp
;; View all buffers (including hidden)
(buffer-list)

;; See all markers in current buffer
(buffer-local-variables)

;; View all overlays
(overlays-in (point-min) (point-max))

;; Memory usage
(memory-use-counts)

;; GC statistics
(garbage-collect)
#+END_SRC

** Debug on Error

#+BEGIN_SRC emacs-lisp
(setq debug-on-error t)
;; Now errors will drop into debugger
#+END_SRC

* References

- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/][GNU Emacs Lisp Reference Manual]]
- =src/= directory in Emacs source tree
- [[info:elisp#Top][Info: Elisp Manual]] (C-h i m Elisp RET)
- =C-h f= and =C-h v= for function/variable documentation

* Source Code Organization

Key source files:
- =src/alloc.c= - Memory allocation and GC
- =src/buffer.c= - Buffer implementation
- =src/xdisp.c= - Display engine (30K+ lines!)
- =src/keyboard.c= - Input handling
- =src/eval.c= - Lisp evaluator
- =src/bytecode.c= - Byte-code interpreter
- =src/syntax.c= - Syntax tables
- =src/process.c= - Process management
- =lisp/simple.el= - Basic editing commands
- =lisp/files.el= - File operations

#+BEGIN_QUOTE
"Emacs is a great operating system, lacking only a decent editor."
— Common joke highlighting Emacs' comprehensive internals
#+END_QUOTE
* Diagrams
** Buffer Internal Structure
#+begin_src plantuml
@startuml Buffer Internal Structure
skinparam componentStyle rectangle

package "Buffer Object (C Structure)" {
    component "Buffer Name" as name {
        [String: "*scratch*"]
    }

    component "Text Storage" as text {
        rectangle "Gap Buffer" {
            [Text Before Gap]
            [GAP (empty space)]
            [Text After Gap]
            note right
                Gap moves to cursor
                for O(1) insertion
            end note
        }
    }

    component "Markers" as markers {
        database "Marker List" {
            [point-marker]
            [mark-marker]
            [user-markers...]
        }
        note right
            Double-linked list
            Auto-adjust on edits
        end note
    }

    component "Text Properties" as props {
        [Interval Tree]
        note right
            Face (syntax highlighting)
            Read-only regions
            Custom properties
        end note
    }

    component "Overlays" as overlays {
        [Overlay List]
        note right
            Temporary decorations
            Don't move with text
            Company popups, etc.
        end note
    }

    component "Mode Information" as modes {
        [Major Mode: python-mode]
        [Minor Modes: List]
        [Keymap]
        [Syntax Table]
    }

    component "Local Variables" as locals {
        [Buffer-local bindings]
        [tab-width: 4]
        [indent-tabs-mode: nil]
    }

    component "Undo Information" as undo {
        [Undo List]
        note right
            Records all changes
            Grouped by command
        end note
    }
}

text --> markers : "positions reference"
text --> props : "attached to"
text <.. overlays : "independent of"
modes --> text : "interprets"
undo --> text : "tracks changes"

@enduml
#+end_src
** Gap Buffer Operations
#+begin_src plantuml
@startuml Gap Buffer Operations
!define CELL rectangle

title Gap Buffer: Efficient Text Editing

state "Initial State" as s1
s1 : Text: "Hello World"
s1 : [H][e][l][l][o][ ][W][o][r][l][d]

state "Move cursor after 'Hello'" as s2
s2 : Cursor moved to position 5
s2 : [H][e][l][l][o][_][_][_][ ][W][o][r][l][d]
s2 : ↑gap_start    ↑gap_end

state "Insert ' beautiful'" as s3
s3 : Inserted 10 characters at gap
s3 : [H][e][l][l][o][ ][b][e][a][u][t][i][f][u][l][ ][W][o][r][l][d]

state "Delete 'beautiful '" as s4
s4 : Gap expanded by deletion
s4 : [H][e][l][l][o][_][_][_][_][_][_][_][_][_][_][ ][W][o][r][l][d]
s4 : ↑gap_start                ↑gap_end

[*] --> s1
s1 --> s2 : Move point
s2 --> s3 : Insert text\n(O(1) at gap)
s3 --> s4 : Delete text\n(O(1) at gap)

note right of s2
    **Gap Movement Cost**
    Copy text between
    old and new position
    O(distance moved)
end note

note right of s3
    **Insertion at Gap**
    - O(1) operation
    - Just advance gap_start
    - No text copying!
end note

note bottom
    Why Gap Buffer?
    - Most edits are consecutive (typing, deleting)
    - Gap stays near cursor
    - Very fast for normal editing patterns
end note

@enduml
#+end_src
** Redisplay Engine
#+begin_src plantuml
@startuml Redisplay Engine
skinparam sequenceMessageAlign center

participant "User Action" as user
participant "Command Loop" as loop
participant "Redisplay\nEngine" as redisplay
participant "Glyph Matrix\nBuilder" as glyph
participant "Screen\nUpdater" as screen
participant "Terminal/GUI" as term

user -> loop: Key press / Command
activate loop

loop -> loop: Execute command
note right: Modify buffer text

loop -> redisplay: Request redisplay
activate redisplay

redisplay -> redisplay: Phase 1:\nDetermine what changed
note right
    Check:
    - Modified buffers
    - Window config changes
    - Scroll position
end note

alt Nothing Changed
    redisplay --> loop: Skip redisplay
else Something Changed
    redisplay -> glyph: Phase 2:\nBuild glyph matrices
    activate glyph

    glyph -> glyph: For each window...
    note right
        1. Apply faces & properties
        2. Handle line wrapping
        3. Process images
        4. Compute bidi text
        5. Apply overlays
    end note

    glyph --> redisplay: Glyph matrices ready
    deactivate glyph

    redisplay -> screen: Phase 3:\nUpdate screen
    activate screen

    screen -> screen: Compare old vs\nnew glyph matrices
    note right
        Optimizations:
        - Scrolling regions
        - Unchanged lines
        - Minimal updates
    end note

    screen -> term: Send display commands
    activate term
    term --> screen: Screen updated
    deactivate term

    deactivate screen
end

deactivate redisplay
loop --> user: Ready for input
deactivate loop

note over redisplay
    **xdisp.c: ~30,000 lines**
    One of the most complex
    parts of Emacs
end note

@enduml
#+end_src
** Garbage Collection
#+begin_src plantuml
@startuml Garbage Collection
!theme plain

title Emacs Garbage Collection (Mark & Sweep)

rectangle "GC Trigger" {
    (Allocation fails) as alloc
    (gc-cons-threshold\nexceeded) as threshold
    (Explicit call to\ngarbage-collect) as explicit
}

rectangle "Mark Phase" {
    rectangle "GC Roots" {
        [All Lisp Variables]
        [Stack Frames]
        [All Buffers]
        [All Windows/Frames]
        [Symbol Obarray]
    }

    agent "Mark Recursively" as mark

    database "Mark Bits" as markbits
}

rectangle "Sweep Phase" {
    collections "Free Lists" {
        folder "Cons Cells"
        folder "Strings"
        folder "Vectors"
        folder "Symbols"
        folder "Floats"
        folder "Markers"
    }

    agent "Free Unmarked\nObjects" as sweep
}

rectangle "Result" {
    (Memory reclaimed)
    (Free lists replenished)
    (Statistics returned)
}

alloc --> [All Lisp Variables]
threshold --> [All Lisp Variables]
explicit --> [All Lisp Variables]

[All Lisp Variables] --> mark
[Stack Frames] --> mark
[All Buffers] --> mark
[All Windows/Frames] --> mark
[Symbol Obarray] --> mark

mark --> markbits : "Set mark bit on\nreachable objects"

markbits --> sweep : "Scan all objects"

sweep --> "Free Lists" : "Free unmarked,\nkeep marked"

"Free Lists" --> (Memory reclaimed)
"Free Lists" --> (Free lists replenished)
"Free Lists" --> (Statistics returned)

note right of mark
    Recursive marking:
    1. Check if already marked
    2. Set mark bit
    3. Recurse into referenced objects
end note

note right of sweep
    For each object type:
    - Scan allocation blocks
    - Free objects without mark bit
    - Clear mark bits on survivors
    - Rebuild free lists
end note

note bottom
    **Performance Tips:**
    • Increase gc-cons-threshold to reduce GC frequency
    • Minimize consing in hot loops
    • Monitor with (garbage-collect) return value
end note

@enduml
#+end_src
** Symbol Structure
#+begin_src plantuml
@startuml Symbol Structure

object "Symbol: 'my-symbol" as sym {
    **name**: "my-symbol"
    **interned**: true
}

object "Value Cell" as value {
    binding = 42
    (variable value)
}

object "Function Cell" as func {
    definition = λ(closure)
    (function definition)
}

object "Property List" as plist {
    doc = "Documentation"
    custom-prop = "value"
    risky-local-variable = t
}

object "Obarray\n(Hash Table)" as obarray {
    "my-symbol" → Symbol*
    "another-symbol" → Symbol*
    ...
}

sym --> value : "symbol-value"
sym --> func : "symbol-function"
sym --> plist : "symbol-plist"

obarray --> sym : "intern 'my-symbol"

note right of sym
    **One symbol, multiple roles:**

    (defvar my-symbol 42)
    ; Uses value cell

    (defun my-symbol () "hi")
    ; Uses function cell

    (put 'my-symbol 'doc "...")
    ; Uses property list
end note

note bottom of obarray
    **Symbol Interning:**

    (eq 'foo 'foo) => t

    All instances of 'foo
    refer to the SAME object
    in memory (interned)
end note

@enduml
#+end_src
** Keymap Lookup Algorithm
#+begin_src plantuml
@startuml Keymap Lookup Algorithm

start

:User presses key sequence\n(e.g., C-x C-f);

:Build key sequence list\n[(?\C-x ?\C-f)];

:Start with first keymap\nin precedence order;

partition "Keymap Search Order" {
    :1. Overriding keymaps\n(overriding-local-map);

    :2. Minor mode keymaps\n(in reverse order);

    :3. Local keymap\n(major mode keymap);

    :4. Global keymap;
}

repeat
    :Look up first key\nin current keymap;

    if (Found?) then (yes)
        if (Is prefix key?) then (yes)
            :Get prefix keymap;
            :Remove first key\nfrom sequence;

            if (More keys?) then (yes)
                :Continue in\nprefix keymap;
            else (no)
                :Show "C-x-"\n(waiting for more);
                stop
            endif
        else (no - command)
            :Found command!;
            stop
        endif
    else (no)
        :Try next keymap\nin precedence;
    endif
repeat while (More keymaps?) is (yes)
->no;

:No binding found;
:Signal error\n"C-x C-f is undefined";

stop

note right
    **Example Precedence:**

    In Python mode with company-mode:
    1. overriding-local-map (if set)
    2. company-mode-map
    3. python-mode-map
       → inherits from prog-mode-map
          → inherits from global-map
    4. global-map (fallback)

    First match wins!
end note

@enduml
#+end_src
** Process Management
#+begin_src plantuml
@startuml Process Management

package "Emacs Process Types" {

    class "Synchronous Process" as sync {
        + call-process()
        + call-process-region()
        --
        Blocks until complete
        Output to buffer
        Return exit code
    }

    class "Asynchronous Process" as async {
        + start-process()
        + make-process()
        --
        Non-blocking
        Filter function for output
        Sentinel for status changes
    }

    class "Network Process" as network {
        + make-network-process()
        --
        TCP/UDP connections
        Client or server
        Same filter/sentinel API
    }

    class "Serial Port" as serial {
        + make-serial-process()
        --
        Hardware communication
        Used for Arduino, etc.
    }
}

object "Process Object" as proc {
    name
    buffer
    command
    pid
    status
    --
    filter-function
    sentinel-function
}

object "Filter Function" as filter {
    (lambda (proc string)
      (handle-output string))
}

object "Sentinel Function" as sentinel {
    (lambda (proc event)
      (handle-state-change event))
}

async --> proc : creates
network --> proc : creates
serial --> proc : creates

proc --> filter : "calls on output"
proc --> sentinel : "calls on status change"

note right of filter
    **Filter receives output:**
    - Called with each chunk
    - Not line-buffered
    - Insert into buffer
    - Parse incrementally
end note

note right of sentinel
    **Sentinel notified on:**
    - Process exit
    - Signal received
    - Connection closed
    - Open/closed events

    Event strings:
    - "finished\n"
    - "exited abnormally\n"
    - "killed\n"
    - "open\n", "closed\n"
end note

actor "External Process" as ext

proc <--> ext : "stdin/stdout/stderr"

note bottom
    **Example: Async LSP Server**

    (setq lsp-proc
      (make-process
       :name "python-lsp"
       :command '("pylsp")
       :filter 'lsp-filter
       :sentinel 'lsp-sentinel
       :connection-type 'pipe))

    (process-send-string lsp-proc json-rpc-msg)
end note

@enduml
#+end_src
** Complete Data Flow
#+begin_src plantuml
@startuml Complete Data Flow

skinparam linetype ortho

actor User

rectangle "Input Layer" {
    component [Keyboard/Mouse] as input
    component [Event Queue] as queue
}

rectangle "Command Layer" {
    component [Key Lookup] as keylookup
    component [Command Execution] as cmd
    component [Elisp Evaluator] as eval
}

rectangle "Data Layer" {
    database "Buffers" as buffers {
        [Gap Buffer]
        [Markers]
        [Properties]
        [Undo List]
    }

    database "State" as state {
        [Windows]
        [Frames]
        [Processes]
        [Variables]
    }
}

rectangle "Display Layer" {
    component [Redisplay Engine] as redisplay
    component [Glyph Builder] as glyph
    component [Screen Updater] as screen
}

rectangle "Output Layer" {
    component [Terminal/X11/NS] as output
}

rectangle "Background" {
    component [Timers] as timers
    component [Idle Tasks] as idle
    component [Process Filters] as filters
}

User --> input
input --> queue
queue --> keylookup
keylookup --> cmd
cmd --> eval

eval <--> buffers : "read/modify"
eval <--> state : "read/modify"

eval --> redisplay : "trigger"
buffers --> redisplay
state --> redisplay

redisplay --> glyph
glyph --> screen
screen --> output
output --> User : "visual feedback"

timers --> eval : "periodic execution"
idle --> eval : "when idle"
filters --> eval : "async output"

note right of eval
    Elisp Interpreter:
    - Evaluates all commands
    - Byte-code execution
    - Native code execution
    - Garbage collection
end note

note bottom of buffers
    Core data structures
    optimized for editing:
    - O(1) insertion at point
    - Efficient property lookup
    - Incremental undo
end note

note right of redisplay
    Only updates screen
    when needed:
    - After commands
    - When idle
    - Never during input
end note

@enduml
#+end_src
