* Emacs Architecture Overview
** Core Architecture Components

*** C Core (Emacs Core)
:PROPERTIES:
:RESPONSIBILITY: Fundamental primitives and performance-critical operations
:PERCENTAGE: ~5% of Emacs codebase
:END:

The C core provides the foundation of Emacs with:

- Basic data structures (buffers, windows, frames)
- Primitive functions for text manipulation
- Low-level I/O operations
- Event loop and display management
- Garbage collector
- Interface to the operating system

*** Emacs Lisp Interpreter
:PROPERTIES:
:RESPONSIBILITY: Executes Elisp code
:END:

The interpreter is the bridge between the C core and the Elisp layer.

**** Features
- Dynamic typing
- Lexical and dynamic scoping support
- Built-in evaluation engine
- Byte-code compiler for improved performance

*** Emacs Lisp Layer
:PROPERTIES:
:RESPONSIBILITY: Implements most of Emacs functionality
:PERCENTAGE: ~95% of Emacs codebase
:END:

The Elisp layer contains the vast majority of Emacs features:

- All editing commands
- Major and minor modes
- User interface elements
- Package system
- Built-in applications (mail, calendar, org-mode, etc.)

**** Key Insight
Most of Emacs (~95%) is written in Elisp, making it highly introspective and modifiable at runtime.

** Architecture Diagrams
*** Component Architecture
[[file:emacs-component-architecture.png]]

Source: [[file:emacs-component-architecture.puml]]
*** Event Flow Sequence Diagram
[[file:emacs-event-flow.png]]

Source: [[file:emacs-event-flow.puml]]
*** Layered Architecture Diagram
[[file:emacs-layered-architecture.png]]

Source: [[file:emacs-layered-architecture.puml]]
*** Buffer-Window-Frame Relationships
[[file:emacs-buffer-window-frame-relationships.png]]

Source: [[file:emacs-buffer-window-frame-relationships.puml]]
*** Extension Mechanism Diagram
[[file:emacs-extension-mechanisms.png]]

Source: [[file:emacs-extension-mechanisms.puml]]
** Key Architectural Concepts

*** Buffers
:PROPERTIES:
:DEFINITION: Central data structure representing text being edited
:END:

- Not necessarily tied to files
- Can contain any text, including:
  + Program output
  + Menus and UI elements
  + Interactive applications
  + Temporary scratch space

*** Windows and Frames

**** Windows
- Viewports into buffers
- Multiple windows can show the same buffer
- Multiple windows can show different buffers
- Split horizontally or vertically

**** Frames
- Top-level windows (what most applications call "windows")
- Can contain multiple windows
- Can be in terminal or GUI mode

*** Modes

**** Major Modes
- Define primary behavior for a buffer
- Only one major mode active per buffer
- Examples:
  + =python-mode=
  + =org-mode=
  + =text-mode=
  + =fundamental-mode=

**** Minor Modes
- Add optional features
- Multiple minor modes can be active simultaneously
- Examples:
  + =auto-save-mode=
  + =line-number-mode=
  + =flycheck-mode=
  + =company-mode=

*** Key Bindings and Command Loop

The event-driven architecture centers around:

- Key presses invoke commands (Elisp functions)
- Highly remappable keybindings
- Multiple keymaps with precedence:
  1. Overriding keymaps
  2. Minor mode keymaps
  3. Major mode keymap
  4. Global keymap

*** Hooks and Advice
:PROPERTIES:
:PURPOSE: Extensibility mechanisms
:END:

**** Hooks
Lists of functions called at specific points in execution.

#+BEGIN_SRC emacs-lisp
;; Example: Add function to hook
(add-hook 'before-save-hook #'delete-trailing-whitespace)
#+END_SRC

Common hooks:
- =before-save-hook=
- =after-save-hook=
- =mode-hook= (e.g., =python-mode-hook=)
- =kill-buffer-hook=

**** Advice
Mechanism to modify behavior of existing functions without changing their source.

#+BEGIN_SRC emacs-lisp
;; Example: Add advice to function
(advice-add 'save-buffer :before #'my-pre-save-function)
#+END_SRC

Advice types:
- =:before= - Run before the original function
- =:after= - Run after the original function
- =:around= - Wrap the original function
- =:override= - Replace the original function

** Data Flow

#+BEGIN_EXAMPLE
User Input → Event Loop → Key Binding → Command (Elisp Function)
    ↓                                           ↓
Display ← Screen Rendering ← Buffer Modification
#+END_EXAMPLE

*** Detailed Flow

1. *User Input* :: User presses a key or performs an action
2. *Event Loop* :: C core captures the event
3. *Key Lookup* :: Key binding system finds associated command
4. *Command Execution* :: Elisp function is evaluated
5. *Buffer Modification* :: Text or state is changed
6. *Display Update* :: Screen is refreshed to show changes
7. *Ready* :: System waits for next input

** What Makes Emacs Architecture Unique

*** Self-documenting System
- Every function has documentation accessible via =C-h f=
- Every variable has documentation accessible via =C-h v=
- Every key binding is inspectable via =C-h k=
- Source code is accessible via =M-.= (jump to definition)

*** Live Environment
You can modify Emacs while it's running:
- Evaluate code with =C-x C-e=
- Redefine functions on the fly
- Load and reload packages
- Change configuration without restarting

*** Everything is Data
- Text is data
- Code is data (homoiconicity of Lisp)
- Configuration is data
- All manipulable through Elisp data structures

*** Extension = Configuration
No distinction between user configuration and extensions:
- Both are Elisp code
- User config (=init.el=) can be as sophisticated as any package
- Packages are just Elisp files
- Seamless integration between core, packages, and user code

** Historical Impact

This architecture has enabled Emacs to:
- Remain relevant for *40+ years*
- Adapt to changing technologies (terminals → X11 → macOS → Wayland)
- Support modern features (LSP, tree-sitter, native compilation)
- Maintain backward compatibility
- Foster a vibrant ecosystem of packages

** Architecture Benefits

*** For Users
- Infinite customization possibilities
- Learn incrementally (start simple, grow expertise)
- Never "hit a wall" in what you can modify
- Community packages extend functionality

*** For Developers
- Easy to extend existing functionality
- Can inspect and learn from existing code
- Rapid prototyping and testing
- Full access to internals

*** For the Ecosystem
- Long-term stability
- Package compatibility
- Shared conventions and idioms
- Collective knowledge accumulation

** References and Further Reading

- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/][Emacs Lisp Reference Manual]]
- [[https://www.gnu.org/software/emacs/manual/html_node/emacs/][Emacs User Manual]]
- [[https://github.com/emacs-mirror/emacs][Emacs Source Code]]
- =C-h i m Elisp RET= (Built-in documentation in Emacs)
- [[file:emacs-internals.org][Deep Dive into Emacs Internals]]

** Footnotes

[fn:1] The exact percentage of C vs Elisp code varies by version, but the principle remains: the C core is minimal, and most functionality is in Elisp.

[fn:2] Modern Emacs (28+) includes native compilation support, which compiles Elisp to native code for better performance while maintaining the same architecture.
